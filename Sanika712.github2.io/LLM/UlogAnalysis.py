# -*- coding: utf-8 -*-
"""RA-TASK1-2.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Yhi5NWu6LQyYF3t0LRJu4NvvncztN_pK
"""

from google.colab import files
uploaded = files.upload()

!pip install pyulog
from pyulog import ULog
import pandas as pd
import os

# Load the uploaded .ulg file
for filename in uploaded.keys():
    ulog = ULog(filename)  # Create ULog object with the uploaded file

# List all available datasets in the ULog file
print("Available datasets:")
for message in ulog.data_list:
    print(f"Dataset: {message.name}")

# Extract relevant datasets as pandas DataFrames
local_position_df = pd.DataFrame(ulog.get_dataset('vehicle_local_position').data)[['timestamp', 'x', 'y', 'z', 'vx', 'vy', 'vz']]
attitude_df = pd.DataFrame(ulog.get_dataset('vehicle_attitude').data)[['timestamp', 'rollspeed', 'pitchspeed', 'yawspeed']]
status_df = pd.DataFrame(ulog.get_dataset('vehicle_status').data)[['timestamp', 'nav_state']]
control_df = pd.DataFrame(ulog.get_dataset('actuator_controls_0').data)[['timestamp', 'control[0]', 'control[1]', 'control[2]']]
sensor_combined_df = pd.DataFrame(ulog.get_dataset('sensor_combined').data)[[
    'timestamp', 'accelerometer_m_s2[0]', 'accelerometer_m_s2[1]', 'accelerometer_m_s2[2]',
    'magnetometer_ga[0]', 'magnetometer_ga[1]', 'magnetometer_ga[2]', 'baro_alt_meter', 'baro_temp_celcius'
]]
sensor_preflight_df = pd.DataFrame(ulog.get_dataset('sensor_preflight').data)
system_power_df = pd.DataFrame(ulog.get_dataset('system_power').data)
battery_status_df = pd.DataFrame(ulog.get_dataset('battery_status').data)
vehicle_land_detected_df = pd.DataFrame(ulog.get_dataset('vehicle_land_detected').data)
vehicle_local_position_df = pd.DataFrame(ulog.get_dataset('vehicle_local_position').data)
vehicle_status_df = pd.DataFrame(ulog.get_dataset('vehicle_status').data)
task_stack_info_df = pd.DataFrame(ulog.get_dataset('task_stack_info').data)
vehicle_attitude_setpoint_df = pd.DataFrame(ulog.get_dataset('vehicle_attitude_setpoint').data)
vehicle_rates_setpoint_df = pd.DataFrame(ulog.get_dataset('vehicle_rates_setpoint').data)
vehicle_land_detected_df = pd.DataFrame(ulog.get_dataset('vehicle_land_detected').data)

# Preview datasets (for debugging and verification)
print(local_position_df.head())
print(attitude_df.head())
print(status_df.head())
print(control_df.head())
print(sensor_combined_df.head())
print(sensor_preflight_df.head())

# Merge datasets on timestamp
merged_df = pd.merge(local_position_df, attitude_df, on='timestamp', how='outer')
merged_df = pd.merge(merged_df, status_df, on='timestamp', how='outer')
merged_df = pd.merge(merged_df, control_df, on='timestamp', how='outer')
merged_df = pd.merge(merged_df, sensor_combined_df, on='timestamp', how='outer')  # Merge sensor_combined_df
merged_df = pd.merge(merged_df, sensor_preflight_df, on='timestamp', how='outer')  # Merge sensor_preflight_df
merged_df = pd.merge(merged_df, system_power_df, on='timestamp', how='outer')
merged_df = pd.merge(merged_df, battery_status_df, on='timestamp', how='outer')
merged_df = pd.merge(merged_df, vehicle_land_detected_df, on='timestamp', how='outer')
merged_df = pd.merge(merged_df, vehicle_local_position_df, on='timestamp', how='outer')
merged_df = pd.merge(merged_df, vehicle_status_df, on='timestamp', how='outer')
merged_df = pd.merge(merged_df, task_stack_info_df, on='timestamp', how='outer')
merged_df = pd.merge(merged_df, vehicle_attitude_setpoint_df, on='timestamp', how='outer')
merged_df = pd.merge(merged_df, vehicle_rates_setpoint_df, on='timestamp', how='outer')

# Interpolate missing values
merged_df = merged_df.interpolate(method='linear')

# Save to CSV
merged_df.to_csv('dataset.csv', index=False)
print("Relevant data saved to dataset.csv")

import os
print(os.getcwd())
from google.colab import files
files.download('dataset.csv')

# Load the dataset
dataset = pd.read_csv('dataset.csv')

# Define a function to fill nulls based on column type
def fill_nulls(df):
    for column in df.columns:
        if df[column].dtype == 'object':
            # Fill nulls in categorical/text columns with mode
            df[column].fillna(df[column].mode()[0], inplace=True)
        else:
            # Fill nulls in numeric columns with mean
            df[column].fillna(df[column].mean(), inplace=True)
    return df

# Apply the function
dataset = fill_nulls(dataset)

# Save the cleaned dataset
dataset.to_csv('cleaned_data.csv', index=False)
print("Cleaned data saved to cleaned_data.csv.")

import pandas as pd
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D

# Assuming the dataset is loaded as 'df'
df = pd.read_csv('cleaned_data.csv')

import os
print(os.getcwd())
from google.colab import files
files.download('cleaned_data.csv')

# Check for null values
null_values = dataset.isnull().sum()

# Print the result
print("Null values in each column:")
print(null_values)

# Print total null values
total_nulls = null_values.sum()
print(f"\nTotal null values in the dataset: {total_nulls}")

import pandas as pd
import numpy as np

# Assuming df is the DataFrame with your mission data
# Example thresholds for analysis
takeoff_thrust_threshold = 0.1
landing_gear_deployed = 1
landing_gear_retracted = 0
thrust_threshold = 0.05  # for hovering/steady flight

# Add a column to classify stages
df['mission_stage'] = 'Unknown'  # Placeholder for mission stages

# Stage 1: Takeoff (when thrust_x or thrust_y exceeds a threshold, landing gear retracts)
takeoff_mask = (df['thrust_x'] > takeoff_thrust_threshold) | (df['thrust_y'] > takeoff_thrust_threshold)
landing_gear_retracted_mask = df['landing_gear'] == landing_gear_retracted
df.loc[takeoff_mask & landing_gear_retracted_mask, 'mission_stage'] = 'Takeoff'

# Stage 2: Hovering (when thrust is low and steady)
hovering_mask = (df['thrust_x'].abs() < thrust_threshold) & (df['thrust_y'].abs() < thrust_threshold)
df.loc[hovering_mask, 'mission_stage'] = 'Hovering'

# Stage 3: Transition to Fixed-Wing (when fw_control_yaw becomes active or flaps are applied)
transition_fw_mask = (df['fw_control_yaw'].notna()) | (df['apply_flaps'] == 1)
df.loc[transition_fw_mask, 'mission_stage'] = 'Transition to Fixed-Wing'

# Stage 4: Landing (when thrust_x or thrust_y decreases below a threshold and landing gear is deployed)
landing_mask = (df['thrust_x'].abs() < thrust_threshold) & (df['thrust_y'].abs() < thrust_threshold) & (df['landing_gear'] == landing_gear_deployed)
df.loc[landing_mask, 'mission_stage'] = 'Landing'

# Stage 5: Post-Landing (when thrust is zero and landing gear remains deployed)
post_landing_mask = (df['thrust_x'] == 0) & (df['thrust_y'] == 0) & (df['landing_gear'] == landing_gear_deployed)
df.loc[post_landing_mask, 'mission_stage'] = 'Post-Landing'

# Optionally, fill in any gaps for remaining flight phases (e.g., cruise, transitions between modes)
df['mission_stage'] = df['mission_stage'].fillna('In-Flight')

# Output the results to verify
print(df[['timestamp', 'mission_stage']].head())

import matplotlib.pyplot as plt

# Plot the mission stages over time
plt.figure(figsize=(10, 6))
plt.scatter(df['timestamp'], df['thrust_x'], c=df['mission_stage'].map({'Takeoff': 1, 'Hovering': 2, 'Transition to Fixed-Wing': 3, 'Landing': 4, 'Post-Landing': 5}), cmap='viridis')
plt.xlabel('Timestamp')
plt.ylabel('Thrust X')
plt.title('Mission Analysis with Stages')
plt.colorbar(label='Mission Stage')
plt.show()

import matplotlib.pyplot as plt
import numpy as np

# Assuming df contains the necessary position data ('x_x', 'y_x', 'z_x')
# Reconstructing the path (if velocity data is available and position is not)
df['reconstructed_x'] = df['x_x'].fillna(0)  # Use velocity if position is missing
df['reconstructed_y'] = df['y_x'].fillna(0)
df['reconstructed_z'] = df['z_x'].fillna(0)

# Optionally, compute the path using velocity if position data is missing
# if velocity and timestamps are available, integrate the velocity to get the position:
df['reconstructed_x'] = np.cumsum(df['vx_x'] * np.diff(df['timestamp'], prepend=df['timestamp'].iloc[0]))
df['reconstructed_y'] = np.cumsum(df['vy_x'] * np.diff(df['timestamp'], prepend=df['timestamp'].iloc[0]))
df['reconstructed_z'] = np.cumsum(df['vz_x'] * np.diff(df['timestamp'], prepend=df['timestamp'].iloc[0]))

# Plot 3D Pathway
fig = plt.figure(figsize=(10, 6))
ax = fig.add_subplot(111, projection='3d')
ax.plot(df['reconstructed_x'], df['reconstructed_y'], df['reconstructed_z'], label='Flight Path', color='b')
ax.set_xlabel('X Position')
ax.set_ylabel('Y Position')
ax.set_zlabel('Z Position')
ax.set_title('Reconstructed Pathway')
plt.legend()
plt.show()

# Plot 2D Pathway (XY plane)
plt.figure(figsize=(8, 6))
plt.plot(df['reconstructed_x'], df['reconstructed_y'], label='Flight Path (XY)', color='r')
plt.xlabel('X Position')
plt.ylabel('Y Position')
plt.title('Reconstructed 2D Pathway (XY Plane)')
plt.legend()
plt.show()

import pandas as pd
import numpy as np
from sklearn.ensemble import RandomForestClassifier
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import LabelEncoder

# Load the dataset
df = pd.read_csv('cleaned_data.csv')

# Example thresholds for analysis (modify based on your dataset)
takeoff_thrust_threshold = 0.1
landing_gear_deployed = 1
landing_gear_retracted = 0
thrust_threshold = 0.05  # for hovering/steady flight

# Add a column to classify stages
df['mission_stage'] = 'Unknown'

# Apply the same logic as before to classify the mission stages
takeoff_mask = (df['thrust_x'] > takeoff_thrust_threshold) | (df['thrust_y'] > takeoff_thrust_threshold)
landing_gear_retracted_mask = df['landing_gear'] == landing_gear_retracted
df.loc[takeoff_mask & landing_gear_retracted_mask, 'mission_stage'] = 'Takeoff'

hovering_mask = (df['thrust_x'].abs() < thrust_threshold) & (df['thrust_y'].abs() < thrust_threshold)
df.loc[hovering_mask, 'mission_stage'] = 'Hovering'

transition_fw_mask = (df['fw_control_yaw'].notna()) | (df['apply_flaps'] == 1)
df.loc[transition_fw_mask, 'mission_stage'] = 'Transition to Fixed-Wing'

landing_mask = (df['thrust_x'].abs() < thrust_threshold) & (df['thrust_y'].abs() < thrust_threshold) & (df['landing_gear'] == landing_gear_deployed)
df.loc[landing_mask, 'mission_stage'] = 'Landing'

post_landing_mask = (df['thrust_x'] == 0) & (df['thrust_y'] == 0) & (df['landing_gear'] == landing_gear_deployed)
df.loc[post_landing_mask, 'mission_stage'] = 'Post-Landing'

df['mission_stage'] = df['mission_stage'].fillna('In-Flight')

# Label encode the mission stages for classification
le = LabelEncoder()
df['mission_stage_encoded'] = le.fit_transform(df['mission_stage'])

# Define the sensors (features)
sensors = ['accelerometer_m_s2[0]', 'accelerometer_m_s2[1]', 'accelerometer_m_s2[2]',
           'magnetometer_ga[0]', 'magnetometer_ga[1]', 'magnetometer_ga[2]',
           'baro_alt_meter', 'baro_temp_celcius', 'accel_inconsistency_m_s_s', 'gyro_inconsistency_rad_s']

# Prepare the features and target
X = df[sensors].fillna(0)  # Replace NaN values if any in the sensor data
y = df['mission_stage_encoded']

# Train a Random Forest Classifier to identify feature importance (critical sensors)
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

rf = RandomForestClassifier(n_estimators=100, random_state=42)
rf.fit(X_train, y_train)

# Get the feature importance scores
feature_importance = rf.feature_importances_

# Create a DataFrame to show sensor importance
sensor_importance_df = pd.DataFrame({
    'Sensor': sensors,
    'Importance': feature_importance
})

# Sort the sensors by their importance
sensor_importance_df = sensor_importance_df.sort_values(by='Importance', ascending=False)

# Output the critical sensors
print("Critical Sensors based on Mission Stages:")
print(sensor_importance_df)